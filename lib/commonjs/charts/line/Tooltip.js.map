{"version":3,"sources":["Tooltip.tsx"],"names":["LineChartTooltip","displayName","children","xGutter","yGutter","cursorGutter","position","textProps","textStyle","at","props","width","height","parsedPath","React","useContext","LineChartDimensionsContext","type","CursorContext","currentX","currentY","isActive","x","elementWidth","elementHeight","handleLayout","useCallback","event","value","nativeEvent","layout","atXPosition","undefined","atYPosition","animatedCursorStyle","translateXOffset","isStatic","xOffset","translateYOffset","y","translateY","opacity","transform","translateX","padding","alignSelf","style"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport Animated, {\n  useAnimatedStyle,\n  useDerivedValue,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\nimport { LineChartPriceText, LineChartPriceTextProps } from './PriceText';\n\nimport { CursorContext } from './Cursor';\nimport { LineChartDimensionsContext } from './Chart';\nimport type { ViewProps } from 'react-native';\nimport { getXPositionForCurve } from './utils/getXPositionForCurve';\nimport { getYForX } from 'react-native-redash';\nimport { useLineChart } from './useLineChart';\nimport { useMemo } from 'react';\n\nexport type LineChartTooltipProps = Animated.AnimateProps<ViewProps> & {\n  children?: React.ReactNode;\n  xGutter?: number;\n  yGutter?: number;\n  cursorGutter?: number;\n  position?: 'top' | 'bottom';\n  textProps?: LineChartPriceTextProps;\n  textStyle?: LineChartPriceTextProps['style'];\n  /**\n   * When specified the tooltip is considered static, and will\n   * always be rendered at the given index, unless there is interaction\n   * with the chart (like interacting with a cursor).\n   *\n   * @default undefined\n   */\n  at?: number;\n};\n\nLineChartTooltip.displayName = 'LineChartTooltip';\n\nexport function LineChartTooltip({\n  children,\n  xGutter = 8,\n  yGutter = 8,\n  cursorGutter = 48,\n  position = 'top',\n  textProps,\n  textStyle,\n  at,\n  ...props\n}: LineChartTooltipProps) {\n  const { width, height, parsedPath } = React.useContext(\n    LineChartDimensionsContext\n  );\n  const { type } = React.useContext(CursorContext);\n  const { currentX, currentY, isActive } = useLineChart();\n\n  const x = useSharedValue(0);\n  const elementWidth = useSharedValue(0);\n  const elementHeight = useSharedValue(0);\n\n  const handleLayout = React.useCallback(\n    (event) => {\n      x.value = event.nativeEvent.layout.x;\n      elementWidth.value = event.nativeEvent.layout.width;\n      elementHeight.value = event.nativeEvent.layout.height;\n    },\n    [elementHeight, elementWidth, x]\n  );\n\n  // When the user set a `at` index, get the index's y & x positions\n  const atXPosition = useMemo(\n    () =>\n      at !== null && at !== undefined\n        ? getXPositionForCurve(parsedPath, at)\n        : undefined,\n    [at, parsedPath]\n  );\n\n  const atYPosition = useDerivedValue(() => {\n    return atXPosition == null\n      ? undefined\n      : getYForX(parsedPath, atXPosition) ?? 0;\n  }, [atXPosition]);\n\n  const animatedCursorStyle = useAnimatedStyle(() => {\n    let translateXOffset = elementWidth.value / 2;\n    // the tooltip is considered static when the user specified an `at` prop\n    const isStatic = atYPosition.value != null;\n\n    // Calculate X position:\n    const x = atXPosition ?? currentX.value;\n    if (x < elementWidth.value / 2 + xGutter) {\n      const xOffset = elementWidth.value / 2 + xGutter - x;\n      translateXOffset = translateXOffset - xOffset;\n    }\n    if (x > width - elementWidth.value / 2 - xGutter) {\n      const xOffset = x - (width - elementWidth.value / 2 - xGutter);\n      translateXOffset = translateXOffset + xOffset;\n    }\n\n    // Calculate Y position:\n    let translateYOffset = 0;\n    const y = atYPosition.value ?? currentY.value;\n    if (position === 'top') {\n      translateYOffset = elementHeight.value / 2 + cursorGutter;\n      if (y - translateYOffset < yGutter) {\n        translateYOffset = y - yGutter;\n      }\n    } else if (position === 'bottom') {\n      translateYOffset = -(elementHeight.value / 2) - cursorGutter / 2;\n      if (y - translateYOffset + elementHeight.value > height - yGutter) {\n        translateYOffset = y - (height - yGutter) + elementHeight.value;\n      }\n    }\n\n    // determine final translateY value\n    let translateY: number | undefined;\n    if (type === 'crosshair' || isStatic) {\n      translateY = y - translateYOffset;\n    } else {\n      if (position === 'top') {\n        translateY = yGutter;\n      } else {\n        translateY = height - elementHeight.value - yGutter;\n      }\n    }\n\n    let opacity = isActive.value ? 1 : 0;\n    if (isStatic) {\n      // Only show static when there is no active cursor\n      opacity = withTiming(isActive.value ? 0 : 1);\n    }\n\n    return {\n      transform: [\n        { translateX: x - translateXOffset },\n        {\n          translateY: translateY,\n        },\n      ],\n      opacity: opacity,\n    };\n  }, [\n    atXPosition,\n    atYPosition.value,\n    currentX.value,\n    currentY.value,\n    cursorGutter,\n    elementHeight.value,\n    elementWidth.value,\n    height,\n    isActive.value,\n    position,\n    type,\n    width,\n    xGutter,\n    yGutter,\n  ]);\n\n  return (\n    <Animated.View\n      onLayout={handleLayout}\n      {...props}\n      style={[\n        {\n          position: 'absolute',\n          padding: 4,\n          alignSelf: 'flex-start',\n        },\n        animatedCursorStyle,\n        props.style,\n      ]}\n    >\n      {children || (\n        <LineChartPriceText index={at} style={[textStyle]} {...textProps} />\n      )}\n    </Animated.View>\n  );\n}\n"]}