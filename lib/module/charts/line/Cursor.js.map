{"version":3,"sources":["Cursor.tsx"],"names":["React","Animated","runOnJS","useAnimatedGestureHandler","LongPressGestureHandler","LineChartDimensionsContext","StyleSheet","bisectCenter","scaleLinear","useLineChart","CursorContext","createContext","type","LineChartCursor","displayName","children","snapToPoint","props","pathWidth","width","parsedPath","useContext","currentX","currentIndex","isActive","data","xDomain","xValues","useMemo","map","timestamp","i","scaleX","domainArray","length","domain","range","linearScalePositionAndIndex","xPosition","xRelative","invert","closestIndex","pathDataDelta","Math","abs","curves","closestPathCurve","max","min","newXPosition","to","move","x","value","onGestureEvent","onActive","minIndex","boundedIndex","round","onEnd","absoluteFill"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport Animated, {\n  runOnJS,\n  useAnimatedGestureHandler,\n} from 'react-native-reanimated';\nimport {\n  GestureEvent,\n  LongPressGestureHandler,\n  LongPressGestureHandlerEventPayload,\n  LongPressGestureHandlerProps,\n} from 'react-native-gesture-handler';\n\nimport { LineChartDimensionsContext } from './Chart';\nimport { StyleSheet } from 'react-native';\nimport { bisectCenter } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nimport { useLineChart } from './useLineChart';\n\nexport type LineChartCursorProps = LongPressGestureHandlerProps & {\n  children: React.ReactNode;\n  type: 'line' | 'crosshair';\n  // Does not work on web due to how the Cursor operates on web\n  snapToPoint?: boolean;\n};\n\nexport const CursorContext = React.createContext({ type: '' });\n\nLineChartCursor.displayName = 'LineChartCursor';\n\nexport function LineChartCursor({\n  children,\n  snapToPoint,\n  type,\n  ...props\n}: LineChartCursorProps) {\n  const { pathWidth: width, parsedPath } = React.useContext(\n    LineChartDimensionsContext\n  );\n  const { currentX, currentIndex, isActive, data, xDomain } = useLineChart();\n  const xValues = React.useMemo(\n    () => data.map(({ timestamp }, i) => (xDomain ? timestamp : i)),\n    [data, xDomain]\n  );\n\n  // Same scale as in /src/charts/line/utils/getPath.ts\n  const scaleX = React.useMemo(() => {\n    const domainArray = xDomain ?? [0, xValues.length];\n    return scaleLinear().domain(domainArray).range([0, width]);\n  }, [width, xDomain, xValues.length]);\n\n  const linearScalePositionAndIndex = ({\n    xPosition,\n  }: {\n    xPosition: number;\n  }) => {\n    if (!parsedPath) {\n      return;\n    }\n\n    // Calculate a scaled timestamp for the current touch position\n    const xRelative = scaleX.invert(xPosition);\n\n    const closestIndex = bisectCenter(xValues, xRelative);\n    const pathDataDelta = Math.abs(parsedPath.curves.length - xValues.length); // sometimes there is a difference between data length and number of path curves.\n    const closestPathCurve = Math.max(\n      Math.min(closestIndex, parsedPath.curves.length + 1) - pathDataDelta,\n      0\n    );\n\n    const newXPosition = (\n      closestIndex > 0\n        ? parsedPath.curves[closestPathCurve].to\n        : parsedPath.move\n    ).x;\n    // Update values\n    currentIndex.value = closestIndex;\n    currentX.value = newXPosition;\n  };\n\n  const onGestureEvent = useAnimatedGestureHandler<\n    GestureEvent<LongPressGestureHandlerEventPayload>\n  >({\n    onActive: ({ x }) => {\n      if (parsedPath) {\n        const xPosition = Math.max(0, x <= width ? x : width);\n        isActive.value = true;\n\n        // on Web, we could drag the cursor to be negative, breaking it\n        // so we clamp the index at 0 to fix it\n        // https://github.com/coinjar/react-native-wagmi-charts/issues/24\n        const minIndex = 0;\n        const boundedIndex = Math.max(\n          minIndex,\n          Math.round(xPosition / width / (1 / (data.length - 1)))\n        );\n\n        if (snapToPoint) {\n          // We have to run this on the JS thread unfortunately as the scaleLinear functions won't work on UI thread\n          runOnJS(linearScalePositionAndIndex)({ xPosition });\n        } else if (!snapToPoint) {\n          currentX.value = xPosition;\n          currentIndex.value = boundedIndex;\n        }\n      }\n    },\n    onEnd: () => {\n      isActive.value = false;\n      currentIndex.value = -1;\n    },\n  });\n\n  return (\n    <CursorContext.Provider value={{ type }}>\n      <LongPressGestureHandler\n        minDurationMs={0}\n        maxDist={999999}\n        onGestureEvent={onGestureEvent}\n        shouldCancelWhenOutside={false}\n        {...props}\n      >\n        <Animated.View style={StyleSheet.absoluteFill}>\n          {children}\n        </Animated.View>\n      </LongPressGestureHandler>\n    </CursorContext.Provider>\n  );\n}\n"]}